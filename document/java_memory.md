# 자바 메모리 구조

## static 
- Class가 컴파일되어 올라감
- 객체 생성없이 사용
- 같은 Class로 생성된 객체들은 static을 공유하며, 가비지 컬렉션되거나 프로그램이 끝날 때까지
- 블록 변수를 처리하므로 수명이 가장 짧음

## stack 
- 생성된 객체의 reference
- 원시타입, 메서드 변수의 계산
- 객체를 referencing할 때까지

## Heap 
- 객체를 위한 영역
- 객체는 생성된 다음 힙 영역의 멤버 필드를 보관
- 생성된 객체가 가비지 컬렉션될 때까지
- Literal Pool 
	- 힙의 한 부분
	- new 키워드를 사용하지 않은 문자열을 저장(ex. String str = "문자열";)

## Gargage Colletction
- 쓰레기를 수집하고 정리
- 클래스를 선언만하고 프로그램 내에서 오랫동안 사용하지 않거나 메모리가 부족하면 JVM에 의해 제거
- ```java
 // ex
 Car car = null; 
 // 객체는 살아있으나 레퍼런스는 잃게 됨 -> 가비지 
 ```
- 

## 포인터 vs 레퍼런스
- 포인터는 객체의 주소를 직접 가리키므로 메모리 주소를 이용해 찾고 변경할 수 있음
- 자바에서는 사용자가 메모리 주소를 설정하거나 조작할 수 없음
- 일단 객체가 생성되면 1차 주소(해시코드)가 자동으로 할당되고 레퍼런스는 2차 주소를 갖게됨
- 1차 주소와 2차 주소는 JVM이 맵핑시키므로 사용자가 메모리 주소를 찾을 수는 없지만, JVM이 메모리도 자동으로 관리해 주어 사용자의 부담 절감
/////////////////
# 초기화 블록(initialization block)
- 클래스 초기화 블록 : 클래스 변수의 복잡한 초기화에 사용. 클래스가 처음 로딩될 때 한 번만 수행
- 인스턴스 초기화 블록 : 인스턴스 변수의 복잡한 초기화에 사용. 인스턴스가 생성될 때마다 수행(생성자보다 먼저 수행)
- ```java
 class InitBlock {
	static {
	 /* 클래스 초기화 블록 */
	}

	{ /* 인스턴스 초기화 블록 */ }	 
 }	
 ```
## static block
- 클래스가 로딩되고 클래스 변수가 준비된 후 자동으로 실행되는 블록
- 한 클래스 안에 여러 개의 static 블록을 넣을 수 있음
- 주로 클래스 변수를 초기화하는 코드를 둠
- 실행순서 
	1. 클래스 로딩
	1. 클래스 변수가 있으면 메모리를 생성
	1. static 블록이 선언된 순서대로 실행

## instance block
- 인스턴스가 생성된 후 자동으로 실행하는 블록
- 한 클래스 안에 여러 개의 인스턴스 블록을 넣을 수 있음
- 인스턴스 변수를 초기화 하는 코드
- 어떤 생성자가 호출되든 그전에 공통으로 초기화시키고 싶은 작업이 있다면 인스턴스 블록에서 처리
- 순서 : 인스턴스 생성 -> 생성자가 호출되기 전에 인스턴스 블록이 선언된 순서대로 실행

## Class 로딩 순서
- JRE 라이브러리 폴더에서 클래스를 찾는다
- 클래스가 없으면 CLASSPATH 환경변수에 지정된 폴더에서 클래스를 찾는다
- 그 클래스 파일이 올바른 바이트코드인지 검증한다
- 올바른 바이트코드라면, Method Area 영역으로 파일을 로딩한다
- 클래스 블록이 있으면 순서대로 그 블록을 실행한다
- 클래스 안에 static block들이 있이면 순서대로 그 블록을 실행한다